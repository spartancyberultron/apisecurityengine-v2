const mongoose = require('mongoose');
const Ticket = require('./ticket.model'); // Adjust the path as needed

const projectVulnerabilitySchema = new mongoose.Schema({
  project: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Project',
  },
  vulnerability: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vulnerability',
  },  
  endpoint: { 
    type: String, 
  },  
  description: {
    type: String, 
  },
  riskAcceptance: {
    type: String, 
  },
  riskAcceptanceReason: {
    type: String, 
  },
  findings: {
    type: [String], 
  },
  sslFindings: {
    type: [Object], 
  },
  additionalCWEs: {
    type: [String], 
  }
}, {
  timestamps: true,
});

// Middleware to create a ticket after saving a ProjectVulnerability record
projectVulnerabilitySchema.post('save', async function(doc) {
  try {
    // Populate the project and vulnerability references
    await doc.populate('vulnerability').execPopulate();
    await doc.populate('project').execPopulate();

    const { project, vulnerability } = doc;

    // Create the ticket
    const ticket = new Ticket({
      title: vulnerability.vulnerabilityName, // Assuming vulnerability has a vulnerabilityName field
      description: `${doc.description} ${doc.findings.join(', ')}`,
      source: 'API Traffic Scan',
      category: 'Security Vulnerability',
      organization: project.user.organization, // Assuming project.user has an organization field
      scanId: project._id // Use project._id as the scanId
    });

    // Save the ticket
    await ticket.save();
  } catch (err) {
    console.error('Error creating ticket:', err);
  }
});

const ProjectVulnerability = mongoose.model('ProjectVulnerability', projectVulnerabilitySchema);

module.exports = ProjectVulnerability;
