const mongoose = require('mongoose');
const Ticket = require('./ticket.model'); // Adjust the path as needed

const attackSurfaceScanVulnerabilitySchema = new mongoose.Schema({
  
  attackSurfaceScan: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AttackSurfaceScan',
  },
  vulnerability: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vulnerability',
  },  
  endpoint: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AttackSurfaceEndpoint',
  },  
  description: {
    type: String, 
  },
  riskAcceptance: {
    type: String, 
  },
  riskAcceptanceReason: {
    type: String, 
  },
  findings: {
    type: [String], 
  },
  sslFindings: {
    type: [Object], 
  },
  additionalCWEs: {
    type: [String], 
  }
}, {
  timestamps: true,
});

// Middleware to create a ticket after saving an AttackSurfaceScanVulnerability record
attackSurfaceScanVulnerabilitySchema.post('save', async function(doc) {
  try {
    // Populate the attackSurfaceScan reference to access its user and _id
    const scan = await doc.populate('attackSurfaceScan').execPopulate();

    // Create the ticket
    const ticket = new Ticket({
      title: doc.vulnerability.vulnerabilityName || 'No Title', // Assuming vulnerability has a vulnerabilityName field
      description: `${doc.description} Findings: ${doc.findings.join(', ')}`,
      source: 'Attack Surface Scan',
      category: 'Security Vulnerability',
      organization: scan.attackSurfaceScan.user.organization, // Assuming user has an organization field
      scanId: scan.attackSurfaceScan._id // Use attackSurfaceScan._id as the scanId
    });

    // Save the ticket
    await ticket.save();
  } catch (err) {
    console.error('Error creating ticket:', err);
  }
});

const AttackSurfaceScanVulnerability = mongoose.model('AttackSurfaceScanVulnerability', attackSurfaceScanVulnerabilitySchema);

module.exports = AttackSurfaceScanVulnerability;
