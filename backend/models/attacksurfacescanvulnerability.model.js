const mongoose = require('mongoose');
const Ticket = require('./ticket.model'); // Adjust the path as needed

const attackSurfaceScanVulnerabilitySchema = new mongoose.Schema({
  
  attackSurfaceScan: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AttackSurfaceScan',
  },
  vulnerability: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vulnerability',
  },  
  endpoint: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AttackSurfaceEndpoint',
  },  
  description: {
    type: String, 
  },
  riskAcceptance: {
    type: String, 
  },
  riskAcceptanceReason: {
    type: String, 
  },
  findings: {
    type: [String], 
  },
  sslFindings: {
    type: [Object], 
  },
  additionalCWEs: {
    type: [String], 
  },
  remediation:{
    type: String, 
  },
  severity:{
    type: String, 
  },
  priority:{
    type: String, 
  },
}, {
  timestamps: true,
});

// Middleware to create a ticket after saving an AttackSurfaceScanVulnerability record
attackSurfaceScanVulnerabilitySchema.post('save', async function(doc) {
  try {
    // Populate the attackSurfaceScan field with nested fields
    const populatedDoc = await doc.populate({
      path: 'attackSurfaceScan',
      populate: {
        path: 'orgProject',
        populate: {
          path: 'organization',
          populate: {
            path: 'primaryUser'
          }
        }
      }
    }).execPopulate();

    // Extract the populated fields
    const attackSurfaceScan = populatedDoc.attackSurfaceScan;
    const orgProject = attackSurfaceScan.orgProject;
    const organization = orgProject.organization;
    const primaryUser = organization.primaryUser;

    // Create the ticket
    const ticket = new Ticket({
      title: doc.vulnerability?.vulnerabilityName || 'No Title', // Use optional chaining
      description: `${doc.description} Findings: ${doc.findings.join(', ')}`,
      source: 'Attack Surface Scan',
      category: 'Security Vulnerability',
      organization: organization._id, // Assuming organization has an _id field
      scanId: attackSurfaceScan._id, // Use attackSurfaceScan._id as the scanId
      status: 'OPEN',
      priority: doc.severity,
      openedBy: primaryUser // Assuming primaryUser is populated
    });

    // Save the ticket
    await ticket.save();
  } catch (err) {
    console.error('Error creating ticket:', err);
  }
});


const AttackSurfaceScanVulnerability = mongoose.model('AttackSurfaceScanVulnerability', attackSurfaceScanVulnerabilitySchema);

module.exports = AttackSurfaceScanVulnerability;
